Description: Adding support for client SSL certificates.
 Now it's possible to supply HTTPS client with a certificate and
 a private key to perform client authentication.  For now this feature
 is implemented only for boost::asio backend.

Author: Vaclav Naydionov (linux rulez) <vaclav@yandex.ru>

--- casablanca-2.6.0.orig/Release/include/cpprest/http_client.h
+++ casablanca-2.6.0/Release/include/cpprest/http_client.h
@@ -255,6 +255,60 @@ public:
     }
 #endif
 
+    /// <summary>
+    /// Gets the client SSL certificate used to authenticate the client.
+    /// </summary>
+    /// <returns>std::string containing client SSL certificate in PEM format.</returns>
+    const std::string &client_certificate() const
+    {
+        return m_client_certificate;
+    }
+
+    /// <summary>
+    /// Sets the client SSL certificate used to authenticate the client.
+    /// </summary>
+    /// <param name="_client_certificate">std::string containing client SSL certificate in PEM format.</param>
+    void set_client_certificate(const std::string &_client_certificate)
+    {
+        m_client_certificate = _client_certificate;
+    }
+
+    /// <summary>
+    /// Gets the client SSL private key used to authenticate the client.
+    /// </summary>
+    /// <returns>std::string containing client SSL private key in PEM format.</returns>
+    const std::string &client_private_key() const
+    {
+        return m_client_private_key;
+    }
+
+    /// <summary>
+    /// Sets the client SSL private key used to authenticate the client.
+    /// </summary>
+    /// <param name="_client_private_key">std::string containing client SSL private key in PEM format.</param>
+    void set_client_private_key(const std::string &_client_private_key)
+    {
+        m_client_private_key = _client_private_key;
+    }
+
+    /// <summary>
+    /// Gets the client certificate authority chain used to authenticate the client.
+    /// </summary>
+    /// <returns>std::string containing client certificate authority chain in PEM format.</returns>
+    const std::string &client_certificate_chain() const
+    {
+        return m_client_certificate_chain;
+    }
+
+    /// <summary>
+    /// Sets the client certificate authority chain used to authenticate the client.
+    /// </summary>
+    /// <param name="_client_certificate_chain">std::string containing client certificate authority chain in PEM format.</param>
+    void set_client_certificate_chain(const std::string &_client_certificate_chain)
+    {
+        m_client_certificate_chain = _client_certificate_chain;
+    }
+
 #ifdef _WIN32
 #if !defined(__cplusplus_winrt)
     /// <summary>
@@ -324,6 +378,9 @@ private:
     // IXmlHttpRequest2 doesn't allow configuration of certificate verification.
     bool m_validate_certificates;
 #endif
+    std::string m_client_certificate;
+    std::string m_client_private_key;
+    std::string m_client_certificate_chain;
 
     std::function<void(native_handle)> m_set_user_nativehandle_options;
 
--- casablanca-2.6.0.orig/Release/src/http/client/http_client_asio.cpp
+++ casablanca-2.6.0/Release/src/http/client/http_client_asio.cpp
@@ -66,7 +66,8 @@ class asio_connection
     friend class asio_connection_pool;
     friend class asio_client;
 public:
-    asio_connection(boost::asio::io_service& io_service, bool use_ssl) :
+    asio_connection(boost::asio::io_service& io_service, bool use_ssl, const boost::asio::const_buffer &client_certificate, const boost::asio::const_buffer &client_private_key,
+            const boost::asio::const_buffer &client_certificate_chain):
     m_socket(io_service),
     m_pool_timer(io_service),
     m_is_reused(false),
@@ -77,8 +78,13 @@ public:
             boost::asio::ssl::context sslContext(boost::asio::ssl::context::sslv23);
             sslContext.set_default_verify_paths();
             sslContext.set_options(boost::asio::ssl::context::default_workarounds);
+            if (boost::asio::buffer_size(client_certificate))
+                sslContext.use_certificate(client_certificate, boost::asio::ssl::context::pem);
+            if (boost::asio::buffer_size(client_private_key))
+                sslContext.use_private_key(client_private_key, boost::asio::ssl::context::pem);
+            if (boost::asio::buffer_size(client_certificate_chain))
+                sslContext.use_certificate_chain(client_certificate_chain);  // PEM format is assumed
             m_ssl_stream = utility::details::make_unique<boost::asio::ssl::stream<boost::asio::ip::tcp::socket &>>(m_socket, sslContext);
-
         }
     }
 
@@ -220,10 +226,14 @@ class asio_connection_pool
 {
 public:
 
-    asio_connection_pool(boost::asio::io_service& io_service, bool use_ssl, const utility::seconds &idle_timeout) :
+    asio_connection_pool(boost::asio::io_service& io_service, bool use_ssl, const utility::seconds &idle_timeout,
+            const std::string &client_certificate, const std::string &client_private_key, const std::string &client_certificate_chain):
     m_io_service(io_service),
     m_timeout_secs(static_cast<int>(idle_timeout.count())),
-    m_use_ssl(use_ssl)
+    m_use_ssl(use_ssl),
+    m_client_certificate(client_certificate),
+    m_client_private_key(client_private_key),
+    m_client_certificate_chain(client_certificate_chain)
     {}
 
     ~asio_connection_pool()
@@ -259,7 +269,10 @@ public:
             lock.unlock();
 
             // No connections in pool => create a new connection instance.
-            return std::make_shared<asio_connection>(m_io_service, m_use_ssl);
+            return std::make_shared<asio_connection>(m_io_service, m_use_ssl,
+                    boost::asio::const_buffer(m_client_certificate.c_str(), m_client_certificate.size()),
+                    boost::asio::const_buffer(m_client_private_key.c_str(), m_client_private_key.size()),
+                    boost::asio::const_buffer(m_client_certificate_chain.c_str(), m_client_certificate_chain.size()));
         }
         else
         {
@@ -296,6 +309,9 @@ private:
     boost::asio::io_service& m_io_service;
     const int m_timeout_secs;
     const bool m_use_ssl;
+    const std::string m_client_certificate;
+    const std::string m_client_private_key;
+    const std::string m_client_certificate_chain;
     std::vector<std::shared_ptr<asio_connection> > m_connections;
     std::mutex m_connections_mutex;
 };
@@ -307,7 +323,10 @@ public:
     : _http_client_communicator(std::move(address), client_config)
     , m_pool(crossplat::threadpool::shared_instance().service(),
              base_uri().scheme() == "https",
-             client_config.timeout())
+             client_config.timeout(),
+             client_config.client_certificate(),
+             client_config.client_private_key(),
+             client_config.client_certificate_chain())
     , m_resolver(crossplat::threadpool::shared_instance().service())
     {}
 
